<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>MBTA Rail Alerts Dashboard â€” 2025</title>
<meta name="description" content="Interactive analytics dashboard visualizing 33,929 MBTA rail service alerts across 49 routes in 2025. Explore trends by cause, severity, route, and time.">
<meta property="og:type" content="website">
<meta property="og:title" content="MBTA Rail Alerts Dashboard â€” 2025">
<meta property="og:description" content="Interactive dashboard visualizing 33,929 MBTA rail service alerts across 49 routes in 2025. Filter by route, severity, cause, and time period.">
<meta property="og:url" content="https://jonsims.github.io/mbta-rail-alerts-dashboard/">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MBTA Rail Alerts Dashboard â€” 2025">
<meta name="twitter:description" content="Interactive dashboard visualizing 33,929 MBTA rail service alerts across 49 routes in 2025.">
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸš‡</text></svg>">
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.7/dist/chart.umd.min.js"></script>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<style>
  :root {
    --bg: #0f1117;
    --surface: #1a1d27;
    --surface2: #232733;
    --border: #2d3241;
    --text: #e4e6ed;
    --text-dim: #8b8fa3;
    --accent: #4f8cff;
    --red: #ff4d6a;
    --orange: #ff9f43;
    --yellow: #ffd43b;
    --green: #51cf66;
    --purple: #b197fc;
    --cyan: #22d3ee;
    --radius: 12px;
    --chart-grid: rgba(45,50,65,0.5);
    --chart-tick: #8b8fa3;
    --chart-label: #e4e6ed;
    --shadow: rgba(0,0,0,0.4);
    --heatmap-text: rgba(255,255,255,0.7);
    color-scheme: dark;
  }
  [data-theme="light"] {
    --bg: #f0f2f5;
    --surface: #ffffff;
    --surface2: #f5f6f8;
    --border: #d8dce6;
    --text: #1a1d27;
    --text-dim: #5f6370;
    --accent: #2563eb;
    --red: #dc2626;
    --orange: #b45309;
    --yellow: #a16207;
    --green: #15803d;
    --purple: #6d28d9;
    --cyan: #0e7490;
    --chart-grid: rgba(0,0,0,0.08);
    --chart-tick: #5f6370;
    --chart-label: #1a1d27;
    --shadow: rgba(0,0,0,0.12);
    --heatmap-text: rgba(0,0,0,0.7);
    color-scheme: light;
  }
  /* Light-mode grade badge contrast fix */
  [data-theme="light"] .grade-badge {
    font-weight: 900;
  }
  [data-theme="light"] .grade-badge[style*="color:#51cf66"] { color: #15803d !important; }
  [data-theme="light"] .grade-badge[style*="color:#94d82d"] { color: #4d7c0f !important; }
  [data-theme="light"] .grade-badge[style*="color:#ffd43b"] { color: #a16207 !important; }
  [data-theme="light"] .grade-badge[style*="color:#ff9f43"] { color: #b45309 !important; }
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
    background: var(--bg); color: var(--text);
    line-height: 1.5; min-height: 100vh;
  }
  header {
    background: var(--surface);
    border-bottom: 1px solid var(--border);
    padding: 20px 32px;
    display: flex; align-items: center; gap: 16px; flex-wrap: wrap;
  }
  header h1 { font-size: 22px; font-weight: 700; white-space: nowrap; }
  header h1 span { color: var(--accent); }
  .filter-bar {
    display: flex; gap: 10px; flex-wrap: wrap; align-items: center; margin-left: auto;
  }
  .filter-bar select, .filter-bar input {
    background: var(--surface2); color: var(--text); border: 1px solid var(--border);
    border-radius: 8px; padding: 7px 12px; font-size: 13px; outline: none; cursor: pointer;
  }
  .filter-bar select:focus, .filter-bar input:focus { border-color: var(--accent); }
  .filter-bar button {
    background: var(--accent); color: #fff; border: none; border-radius: 8px;
    padding: 7px 16px; font-size: 13px; cursor: pointer; font-weight: 600;
  }
  .filter-bar button:hover { opacity: 0.85; }
  .active-filters {
    display: flex; gap: 6px; flex-wrap: wrap; padding: 0 32px; margin-top: -4px;
  }
  .filter-tag {
    background: var(--accent); color: #fff; font-size: 12px; padding: 3px 10px;
    border-radius: 20px; display: flex; align-items: center; gap: 5px; cursor: pointer;
  }
  .filter-tag:hover { opacity: 0.75; }
  .filter-tag .x { font-weight: 700; }
  main { padding: 20px 32px 40px; max-width: 1600px; margin: 0 auto; }

  /* Data quality banner */
  .dq-banner {
    background: rgba(255, 159, 67, 0.12); border: 1px solid rgba(255, 159, 67, 0.3);
    border-radius: var(--radius); padding: 12px 20px; margin-bottom: 20px;
    font-size: 13px; color: var(--orange); display: none;
  }
  .dq-banner strong { color: var(--text); }

  /* Summary cards */
  .cards { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px; margin-bottom: 16px; }
  .card {
    background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius);
    padding: 20px; position: relative; overflow: hidden;
  }
  .card .label { font-size: 12px; color: var(--text-dim); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 4px; }
  .card .value { font-size: 28px; font-weight: 700; }
  .card .sub { font-size: 13px; color: var(--text-dim); margin-top: 4px; }
  .card .bar { position: absolute; bottom: 0; left: 0; right: 0; height: 4px; }

  /* Context text */
  .context-text {
    background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius);
    padding: 16px 20px; margin-bottom: 20px; font-size: 14px; line-height: 1.7;
    color: var(--text-dim);
  }
  .context-text strong { color: var(--text); }
  .context-text .highlight { color: var(--accent); font-weight: 600; }
  .context-text .bad { color: var(--red); font-weight: 600; }

  /* Chart containers */
  .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px; }
  @media (max-width: 1100px) { .grid-2 { grid-template-columns: 1fr; } }
  .panel {
    background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius);
    padding: 20px; position: relative;
  }
  .panel h2 {
    font-size: 15px; font-weight: 600; margin-bottom: 14px;
    display: flex; align-items: center; gap: 10px;
  }
  .panel h2 .toggle-group {
    display: flex; gap: 0; margin-left: auto; border: 1px solid var(--border); border-radius: 6px; overflow: hidden;
  }
  .panel h2 .toggle-btn {
    background: transparent; color: var(--text-dim); border: none; padding: 4px 10px;
    font-size: 11px; cursor: pointer; border-right: 1px solid var(--border);
  }
  .panel h2 .toggle-btn:last-child { border-right: none; }
  .panel h2 .toggle-btn.active { background: var(--accent); color: #fff; }
  .chart-wrap { position: relative; width: 100%; }
  .chart-wrap canvas { width: 100% !important; }

  /* Route table */
  .route-table-wrap { max-height: 500px; overflow-y: auto; overflow-x: auto; -webkit-overflow-scrolling: touch; }
  .route-table-wrap::-webkit-scrollbar { width: 6px; }
  .route-table-wrap::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
  table { width: 100%; border-collapse: collapse; font-size: 13px; }
  th { position: sticky; top: 0; background: var(--surface); color: var(--text-dim);
    text-align: left; padding: 8px 10px; font-weight: 600; cursor: pointer;
    border-bottom: 2px solid var(--border); font-size: 11px; text-transform: uppercase;
    letter-spacing: 0.5px; white-space: nowrap; user-select: none;
  }
  th:hover { color: var(--accent); }
  th .sort-arrow { margin-left: 3px; font-size: 10px; }
  td { padding: 7px 10px; border-bottom: 1px solid var(--border); }
  tr:hover td { background: var(--surface2); }
  tr.selected td { background: rgba(79, 140, 255, 0.15); }
  .sev-bar { display: flex; height: 6px; border-radius: 3px; overflow: hidden; min-width: 80px; }
  .sev-bar .s { background: var(--red); }
  .sev-bar .w { background: var(--orange); }
  .sev-bar .i { background: var(--green); }
  .type-badge {
    display: inline-block; padding: 2px 8px; border-radius: 10px; font-size: 11px;
    font-weight: 600; white-space: nowrap;
  }
  .type-badge.bus { background: rgba(255, 159, 67, 0.2); color: var(--orange); }
  .type-badge.subway { background: rgba(79, 140, 255, 0.2); color: var(--accent); }
  .type-badge.commuter { background: rgba(177, 151, 252, 0.2); color: var(--purple); }
  .type-badge.light { background: rgba(81, 207, 102, 0.2); color: var(--green); }
  .type-badge.ferry { background: rgba(34, 211, 238, 0.2); color: var(--cyan); }
  .type-badge.other { background: rgba(139, 143, 163, 0.2); color: var(--text-dim); }
  .grade-badge {
    display: inline-block; width: 28px; height: 28px; border-radius: 6px;
    font-size: 14px; font-weight: 800; text-align: center; line-height: 28px;
  }

  /* Heatmap */
  .heatmap-grid {
    display: grid; grid-template-columns: 50px repeat(24, 1fr); gap: 2px; font-size: 11px;
  }
  .heatmap-grid .row-label {
    display: flex; align-items: center; justify-content: flex-end;
    padding-right: 8px; color: var(--text-dim); font-weight: 600;
  }
  .heatmap-grid .col-label {
    text-align: center; color: var(--text-dim); font-weight: 600; padding: 2px 0;
  }
  .heatmap-grid .cell {
    aspect-ratio: 1; border-radius: 3px; display: flex; align-items: center;
    justify-content: center; font-size: 9px; color: var(--heatmap-text);
    cursor: pointer; transition: transform 0.1s;
  }
  .heatmap-grid .cell:hover { transform: scale(1.3); z-index: 2; }

  /* Tooltip */
  .tooltip {
    position: fixed; background: var(--surface2); border: 1px solid var(--border);
    border-radius: 8px; padding: 10px 14px; font-size: 12px; pointer-events: none;
    z-index: 1000; box-shadow: 0 8px 24px var(--shadow); display: none; max-width: 280px;
  }
  .tooltip .tt-title { font-weight: 700; margin-bottom: 4px; }
  .tooltip .tt-value { color: var(--accent); font-size: 18px; font-weight: 700; }
  .tooltip .tt-detail { color: var(--text-dim); margin-top: 2px; }

  /* Modal */
  .modal-overlay {
    position: fixed; inset: 0; background: rgba(0,0,0,0.6); z-index: 999;
    display: none; align-items: center; justify-content: center;
  }
  .modal-overlay.show { display: flex; }
  .modal {
    background: var(--surface); border: 1px solid var(--border); border-radius: 16px;
    padding: 28px; width: 90%; max-width: 700px; max-height: 85vh; overflow-y: auto; position: relative;
  }
  .modal h2 { font-size: 20px; margin-bottom: 16px; }
  .modal .close-btn {
    position: absolute; top: 16px; right: 16px; background: var(--surface2);
    border: 1px solid var(--border); border-radius: 8px; width: 32px; height: 32px;
    display: flex; align-items: center; justify-content: center;
    color: var(--text); cursor: pointer; font-size: 16px;
  }
  .modal .close-btn:hover { background: var(--border); }
  .modal .stat-row { display: flex; gap: 16px; margin-bottom: 16px; flex-wrap: wrap; }
  .modal .stat { flex: 1; min-width: 100px; }
  .modal .stat .label { font-size: 11px; color: var(--text-dim); text-transform: uppercase; }
  .modal .stat .val { font-size: 22px; font-weight: 700; }
  .modal .chart-wrap { height: 200px; margin-top: 12px; }

  .loading { text-align: center; padding: 80px 20px; color: var(--text-dim); font-size: 16px; }
  .loading .spinner {
    width: 40px; height: 40px; border: 3px solid var(--border);
    border-top-color: var(--accent); border-radius: 50%;
    animation: spin 0.8s linear infinite; margin: 0 auto 16px;
  }
  @keyframes spin { to { transform: rotate(360deg); } }
  .full-width { margin-bottom: 20px; }
  .search-box {
    background: var(--surface2); color: var(--text); border: 1px solid var(--border);
    border-radius: 8px; padding: 7px 12px; font-size: 13px; outline: none; width: 200px;
  }
  .search-box:focus { border-color: var(--accent); }

  /* Leaflet map */
  #map { background: var(--bg); z-index: 1; }
  .leaflet-popup-content-wrapper {
    background: var(--surface2); color: var(--text);
    border: 1px solid var(--border); border-radius: 10px;
    box-shadow: 0 8px 24px var(--shadow);
  }
  .leaflet-popup-tip { background: var(--surface2); }
  .leaflet-popup-content { font-size: 13px; line-height: 1.6; margin: 12px 16px; }
  .leaflet-popup-close-button { color: var(--text-dim) !important; font-size: 18px !important; }
  .route-popup-title { font-size: 16px; font-weight: 700; margin-bottom: 6px; }
  .route-popup-grade {
    display: inline-block; padding: 2px 10px; border-radius: 6px;
    font-weight: 800; font-size: 14px;
  }
  .route-popup-stats { margin-top: 8px; }
  .route-popup-stats strong { color: var(--text); }
  .map-legend {
    display: flex; gap: 16px; flex-wrap: wrap; margin-top: 12px;
    padding: 8px 0; font-size: 12px; color: var(--text-dim);
  }
  .map-legend .legend-item { display: flex; align-items: center; gap: 6px; }
  .map-legend .legend-swatch { width: 24px; height: 4px; border-radius: 2px; }
  .map-legend .legend-note { margin-left: auto; font-style: italic; }

  /* Grade info tooltip */
  .grade-info {
    position: relative; display: inline-block; cursor: help; margin-left: 2px;
    color: var(--text-dim); font-size: 12px; font-weight: 400;
  }
  .grade-info .grade-tip {
    display: none; position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%);
    background: var(--surface2); border: 1px solid var(--border); border-radius: 8px;
    padding: 10px 14px; font-size: 12px; white-space: nowrap; z-index: 100;
    box-shadow: 0 8px 24px var(--shadow); color: var(--text); text-transform: none;
    letter-spacing: 0; font-weight: 400; line-height: 1.6;
  }
  .grade-info:hover .grade-tip { display: block; }

  /* Screen reader only */
  .sr-only {
    position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px;
    overflow: hidden; clip: rect(0,0,0,0); white-space: nowrap; border: 0;
  }

  /* Export button */
  .export-btn {
    background: var(--surface2); color: var(--text-dim); border: 1px solid var(--border);
    border-radius: 8px; padding: 7px 14px; font-size: 12px; cursor: pointer; font-weight: 600;
    white-space: nowrap;
  }
  .export-btn:hover { color: var(--text); border-color: var(--accent); }

  /* About panel */
  .about-btn {
    background: transparent; color: var(--text-dim); border: 1px solid var(--border);
    border-radius: 8px; padding: 5px 12px; font-size: 12px; cursor: pointer; white-space: nowrap;
  }
  .about-btn:hover { color: var(--text); border-color: var(--accent); }
  .about-overlay {
    position: fixed; inset: 0; background: rgba(0,0,0,0.6); z-index: 998;
    display: none; align-items: center; justify-content: center;
  }
  .about-overlay.show { display: flex; }
  .about-panel {
    background: var(--surface); border: 1px solid var(--border); border-radius: 16px;
    padding: 28px; width: 90%; max-width: 600px; max-height: 85vh; overflow-y: auto;
    position: relative; font-size: 14px; line-height: 1.7; color: var(--text-dim);
  }
  .about-panel h2 { font-size: 20px; color: var(--text); margin-bottom: 12px; }
  .about-panel h3 { font-size: 14px; color: var(--text); margin: 14px 0 6px; }
  .about-panel a { color: var(--accent); }
  .about-panel .close-btn {
    position: absolute; top: 16px; right: 16px; background: var(--surface2);
    border: 1px solid var(--border); border-radius: 8px; width: 32px; height: 32px;
    display: flex; align-items: center; justify-content: center;
    color: var(--text); cursor: pointer; font-size: 16px;
  }

  /* Theme toggle */
  .theme-toggle {
    display: flex; gap: 0; border: 1px solid var(--border); border-radius: 6px; overflow: hidden;
  }
  .theme-toggle button {
    background: transparent; color: var(--text-dim); border: none; padding: 5px 10px;
    font-size: 12px; cursor: pointer; border-right: 1px solid var(--border); white-space: nowrap;
  }
  .theme-toggle button:last-child { border-right: none; }
  .theme-toggle button.active { background: var(--accent); color: #fff; }

  /* Help tooltip (?) */
  .help-icon {
    display: inline-flex; align-items: center; justify-content: center;
    width: 20px; height: 20px; border-radius: 50%; border: 1px solid var(--border);
    color: var(--text-dim); font-size: 11px; font-weight: 600; cursor: help;
    flex-shrink: 0; line-height: 1; vertical-align: middle;
    font-style: normal; font-family: -apple-system, BlinkMacSystemFont, sans-serif;
  }
  .help-icon:focus-visible { outline: 2px solid var(--accent); outline-offset: 2px; }
  .help-icon:hover { color: var(--accent); border-color: var(--accent); }
  .help-popup {
    position: fixed; z-index: 1001; background: var(--surface); border: 1px solid var(--border);
    border-radius: 10px; padding: 14px 18px; max-width: 340px; font-size: 13px;
    line-height: 1.6; color: var(--text-dim); box-shadow: 0 8px 24px var(--shadow);
    display: none; pointer-events: none;
  }
  .help-popup strong { color: var(--text); }

  /* Data freshness bar */
  .data-meta {
    font-size: 11px; color: var(--text-dim); display: flex; gap: 12px; align-items: center;
    white-space: nowrap;
  }

  /* Error state */
  .error-state {
    text-align: center; padding: 60px 20px; color: var(--red); font-size: 16px;
  }

  /* Mobile: 600px */
  @media (max-width: 600px) {
    header { padding: 16px; gap: 10px; }
    .filter-bar { flex-direction: column; width: 100%; margin-left: 0; }
    .filter-bar select, .filter-bar button { width: 100%; }
    main { padding: 12px 16px 32px; }
    .cards { grid-template-columns: 1fr 1fr; gap: 10px; }
    .card { padding: 14px; }
    .card .value { font-size: 22px; }
    #map { height: 320px !important; }
    .heatmap-grid { overflow-x: auto; font-size: 9px; }
    .heatmap-grid .cell { font-size: 7px; }
    .modal { padding: 20px; }
    .modal .stat-row { gap: 10px; }
    .modal .stat .val { font-size: 18px; }
    .active-filters { padding: 0 16px; }
  }
  @media (prefers-reduced-motion: reduce) {
    *, *::before, *::after {
      animation-duration: 0.01ms !important;
      animation-iteration-count: 1 !important;
      transition-duration: 0.01ms !important;
      scroll-behavior: auto !important;
    }
  }
</style>
<script>
// Early theme application to prevent FOUC
(function(){var p=localStorage.getItem('mbta-theme')||'system';if(p==='system'){var d=window.matchMedia('(prefers-color-scheme: dark)').matches;document.documentElement.setAttribute('data-theme',d?'dark':'light')}else{document.documentElement.setAttribute('data-theme',p)}})();
</script>
</head>
<body>

<header>
  <h1>MBTA <span>Rail Alerts</span> Dashboard â€” 2025</h1>
  <div class="data-meta" id="dataMeta"></div>
  <div class="theme-toggle" id="themeToggle">
    <button data-theme="light">Light</button>
    <button data-theme="dark">Dark</button>
    <button data-theme="system" class="active">Auto</button>
  </div>
  <button class="about-btn" id="aboutBtn">About</button>
  <div class="filter-bar">
    <label for="filterRouteType" class="sr-only">Route Type</label>
    <select id="filterRouteType"><option value="">All Route Types</option></select>
    <label for="filterRoute" class="sr-only">Route</label>
    <select id="filterRoute"><option value="">All Routes</option></select>
    <label for="filterCause" class="sr-only">Cause</label>
    <select id="filterCause"><option value="">All Causes</option></select>
    <label for="filterSeverity" class="sr-only">Severity</label>
    <select id="filterSeverity">
      <option value="">All Severities</option>
      <option value="SEVERE">Severe</option>
      <option value="WARNING">Warning</option>
      <option value="INFO">Info</option>
    </select>
    <label for="filterMonthFrom" class="sr-only">From Month</label>
    <select id="filterMonthFrom"><option value="">From Month</option></select>
    <label for="filterMonthTo" class="sr-only">To Month</label>
    <select id="filterMonthTo"><option value="">To Month</option></select>
    <button id="clearFilters">Clear All</button>
  </div>
</header>
<div class="active-filters" id="activeFilters"></div>

<main>
  <div class="loading" id="loading">
    <div class="spinner"></div>
    Loading alert data...
  </div>
  <div id="dashboard" style="display:none">

    <!-- Data Quality Banner -->
    <div class="dq-banner" id="dataQualityBanner"></div>

    <!-- Summary Cards -->
    <div class="cards" id="summaryCards"></div>

    <!-- Context Text -->
    <div class="context-text" id="contextText"></div>

    <!-- Rail Network Map -->
    <div class="panel full-width">
      <h2>Rail Network Alert Map <span class="help-icon" tabindex="0" role="button" data-help="map">?</span></h2>
      <div id="map" style="height:480px; border-radius:8px; overflow:hidden;"></div>
      <div class="map-legend" id="mapLegend"></div>
    </div>

    <!-- Duration Summary -->
    <div class="panel full-width" id="durationPanel">
      <h2>Alert Duration <span class="help-icon" tabindex="0" role="button" data-help="duration">?</span></h2>
      <div id="durationContent" style="display:flex;gap:20px;flex-wrap:wrap;"></div>
    </div>

    <!-- Monthly Trend -->
    <div class="panel full-width" id="trendPanel">
      <h2>
        <span id="trendTitleText">Monthly Alert Trend</span> <span class="help-icon" tabindex="0" role="button" data-help="trend">?</span>
        <div class="toggle-group" id="trendToggle">
          <button class="toggle-btn active" data-mode="cause">Cause</button>
          <button class="toggle-btn" data-mode="severity">Severity</button>
          <button class="toggle-btn" data-mode="routeType">Route Type</button>
          <button class="toggle-btn" data-mode="effect">Effect</button>
        </div>
      </h2>
      <div class="chart-wrap" style="height:320px"><canvas id="trendChart" aria-label="Stacked bar chart showing monthly alert trends"></canvas></div>
    </div>

    <!-- Effect & Cause (effects promoted â€” 100% classified vs ~6% for causes) -->
    <div class="grid-2" id="causeEffectRow">
      <div class="panel" id="effectPanel">
        <h2>Alerts by Effect <span class="help-icon" tabindex="0" role="button" data-help="effect">?</span></h2>
        <div class="chart-wrap" style="height:300px"><canvas id="effectChart" aria-label="Horizontal bar chart showing alert counts by effect type"></canvas></div>
      </div>
      <div class="panel" id="causePanel">
        <h2>Alerts by Cause <span class="help-icon" tabindex="0" role="button" data-help="cause">?</span> <span style="font-weight:400;color:var(--text-dim);font-size:12px" id="causeSubtitle">(known causes only â€” ~6% of alerts)</span></h2>
        <div class="chart-wrap" style="height:300px"><canvas id="causeChart" aria-label="Horizontal bar chart showing alert counts by known cause"></canvas></div>
      </div>
    </div>

    <!-- Severity + Route Type -->
    <div class="grid-2" id="sevRtRow">
      <div class="panel" id="severityPanel">
        <h2>Severity Distribution <span class="help-icon" tabindex="0" role="button" data-help="severity">?</span></h2>
        <div class="chart-wrap" style="height:280px"><canvas id="severityChart" aria-label="Doughnut chart showing severity distribution"></canvas></div>
      </div>
      <div class="panel" id="routeTypePanel">
        <h2>Alerts by Route Type <span class="help-icon" tabindex="0" role="button" data-help="routeType">?</span></h2>
        <div class="chart-wrap" style="height:280px"><canvas id="routeTypeChart" aria-label="Doughnut chart showing alerts by route type"></canvas></div>
      </div>
    </div>

    <!-- Heatmap -->
    <div class="panel full-width" id="heatmapPanel">
      <h2>Alert Start Time Distribution <span class="help-icon" tabindex="0" role="button" data-help="heatmap">?</span> <span style="font-weight:400;color:var(--text-dim);font-size:12px">(Day of Week x Hour â€” when alerts begin)</span></h2>
      <div id="heatmapContainer"></div>
    </div>

    <!-- Route Table -->
    <div class="panel full-width">
      <h2>
        Route Analysis <span class="help-icon" tabindex="0" role="button" data-help="routeTable">?</span>
        <input type="text" class="search-box" id="routeSearch" placeholder="Search routes..." aria-label="Search routes">
        <button class="export-btn" id="exportCsv">Export CSV</button>
      </h2>
      <div class="route-table-wrap">
        <table id="routeTable">
          <thead><tr>
            <th data-col="id">Route <span class="sort-arrow"></span></th>
            <th data-col="type">Type <span class="sort-arrow"></span></th>
            <th data-col="grade">Grade <span class="grade-info">&#9432;<span class="grade-tip">Reliability grade based on severe alerts/day:<br>A: &lt;0.2 &middot; B: &lt;1.0 &middot; C: &lt;3.0<br>D: &lt;6.0 &middot; F: &ge;6.0</span></span> <span class="sort-arrow"></span></th>
            <th data-col="perDay" title="Average alerts per day in filtered period">Alerts/Day <span class="sort-arrow"></span></th>
            <th data-col="count">Total <span class="sort-arrow"></span></th>
            <th data-col="avgSev">Avg Sev <span class="sort-arrow"></span></th>
            <th data-col="topCause">Top Cause <span class="sort-arrow"></span></th>
            <th data-col="medDur" title="Median alert duration">Duration <span class="sort-arrow"></span></th>
            <th>Severity</th>
          </tr></thead>
          <tbody id="routeTableBody"></tbody>
        </table>
      </div>
    </div>
  </div>
</main>

<!-- Help Popup -->
<div class="help-popup" id="helpPopup"></div>

<!-- Tooltip -->
<div class="tooltip" id="tooltip">
  <div class="tt-title"></div>
  <div class="tt-value"></div>
  <div class="tt-detail"></div>
</div>

<!-- Route Modal -->
<div class="modal-overlay" id="routeModal" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
  <div class="modal">
    <button class="close-btn" id="modalClose" aria-label="Close modal">&times;</button>
    <h2 id="modalTitle"></h2>
    <div class="stat-row" id="modalStats"></div>
    <div class="chart-wrap" style="height:220px"><canvas id="modalTrendChart"></canvas></div>
    <div style="margin-top:16px">
      <h2 style="font-size:14px; margin-bottom:8px">Severity Breakdown</h2>
      <div class="chart-wrap" style="height:180px"><canvas id="modalSevChart"></canvas></div>
    </div>
  </div>
</div>

<!-- About Modal -->
<div class="about-overlay" id="aboutOverlay" role="dialog" aria-modal="true" aria-labelledby="aboutTitle">
  <div class="about-panel">
    <button class="close-btn" id="aboutClose" aria-label="Close about panel">&times;</button>
    <h2 id="aboutTitle">About This Dashboard</h2>
    <p>This dashboard visualizes <strong>2025 MBTA rail service alerts</strong> across Subway, Green Line (Light Rail), and Commuter Rail routes. It covers 33,929 unique alerts across 22 routes over 12 months.</p>
    <h3>Data Source</h3>
    <p>Alert data from the <a href="https://www.mbta.com/developers" target="_blank">MBTA V3 API</a>, processed from monthly CSV exports. Route shapes fetched from the MBTA route patterns API.</p>
    <h3>Known Limitations</h3>
    <p><strong>~94% of alert causes are "Unknown"</strong> â€” this is a source MBTA data quality issue. The cause charts show only the ~6% with identified causes. Effect data (Delay, Shuttle, etc.) is 100% classified and more reliable.</p>
    <p><strong>Alert duration â‰  delay duration.</strong> The duration statistics measure how long each alert was active, not how long individual riders were delayed.</p>
    <p><strong>No ridership weighting.</strong> Alert counts are not normalized by ridership, so high-ridership routes may appear comparable to low-ridership routes.</p>
    <h3>Methodology</h3>
    <p><strong>Grading:</strong> Letter grades are based on severe alerts per day: A (&lt;0.2), B (&lt;1.0), C (&lt;3.0), D (&lt;6.0), F (â‰¥6.0).</p>
    <p><strong>Deduplication:</strong> Each alert is counted once per month per aggregation level, using the row with the latest modification timestamp.</p>
    <p><strong>Duration cap:</strong> Alerts longer than 30 days are excluded from duration statistics as outliers.</p>
  </div>
</div>

<script>
// â”€â”€â”€â”€ Theme â”€â”€â”€â”€
(function initTheme() {
  const saved = localStorage.getItem('mbta-theme') || 'system';
  applyThemePref(saved);
  // Mark the correct toggle button active
  document.querySelectorAll('#themeToggle button').forEach(b => {
    b.classList.toggle('active', b.dataset.theme === saved);
  });
})();

function applyThemePref(pref) {
  localStorage.setItem('mbta-theme', pref);
  if (pref === 'system') {
    const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
    document.documentElement.setAttribute('data-theme', isDark ? 'dark' : 'light');
  } else {
    document.documentElement.setAttribute('data-theme', pref);
  }
}

function getEffectiveTheme() {
  return document.documentElement.getAttribute('data-theme') || 'dark';
}

document.getElementById('themeToggle').addEventListener('click', e => {
  const btn = e.target.closest('button');
  if (!btn) return;
  const pref = btn.dataset.theme;
  applyThemePref(pref);
  document.querySelectorAll('#themeToggle button').forEach(b => b.classList.toggle('active', b === btn));
  refreshChartsForTheme();
  refreshMapForTheme();
});

// React to OS theme changes when in system mode
window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
  if (localStorage.getItem('mbta-theme') === 'system') {
    applyThemePref('system');
    refreshChartsForTheme();
    refreshMapForTheme();
  }
});

function getChartColors() {
  const s = getComputedStyle(document.documentElement);
  return {
    tick: s.getPropertyValue('--chart-tick').trim(),
    label: s.getPropertyValue('--chart-label').trim(),
    grid: s.getPropertyValue('--chart-grid').trim(),
  };
}

let mapTileLayer = null;
function refreshMapForTheme() {
  if (!mapObj) return;
  const theme = getEffectiveTheme();
  const tileUrl = theme === 'light'
    ? 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png'
    : 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png';
  if (mapTileLayer) mapObj.removeLayer(mapTileLayer);
  mapTileLayer = L.tileLayer(tileUrl, {
    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OSM</a> &copy; <a href="https://carto.com/">CARTO</a>',
    subdomains: 'abcd', maxZoom: 19,
  }).addTo(mapObj);
  // Ensure route layers are on top
  Object.values(mapLayers).forEach(l => l.bringToFront());
}

function refreshChartsForTheme() {
  // Re-render all charts to pick up new CSS variable colors
  if (DATA) renderAll();
}

// â”€â”€â”€â”€ Help Tooltips â”€â”€â”€â”€
const HELP_TEXT = {
  map: '<strong>Rail Network Alert Map</strong> â€” Shows all MBTA rail routes color-coded by their official line colors. Thicker, more opaque lines indicate worse reliability grades (more severe alerts per day). Click any route to see its stats.',
  duration: '<strong>Alert Duration</strong> â€” How long each alert stayed active, not how long riders were delayed. Median is the typical duration; the 90th percentile shows the worst 10% of cases. Alerts over 30 days are excluded as outliers.',
  trend: '<strong>Monthly Alert Trend</strong> â€” Stacked bar chart showing alert volume by month. Toggle between Cause, Severity, Route Type, and Effect views. In "Cause" mode, only the ~6% of alerts with known causes are shown. Click a bar to filter to that month.',
  effect: '<strong>Alerts by Effect</strong> â€” What happened as a result of each alert (Delay, Shuttle, Stop Closure, etc.). Effect data is 100% classified by the MBTA, making it the most reliable breakdown. Click a bar to filter by that effect.',
  cause: '<strong>Alerts by Cause</strong> â€” Why the alert was issued (Signal Problem, Disabled Train, etc.). Only ~6% of alerts have a known cause; the rest are "Unknown" and excluded here. This limits what we can learn about root causes.',
  severity: '<strong>Severity Distribution</strong> â€” MBTA-assigned severity levels: <strong>Severe</strong> (major disruption), <strong>Warning</strong> (moderate impact), and <strong>Info</strong> (advisory, low impact). Click a slice to filter the dashboard by that severity.',
  routeType: '<strong>Alerts by Route Type</strong> â€” Breaks down alerts across Subway, Green Line (Light Rail), and Commuter Rail. Route types have very different alert patterns due to infrastructure and ridership differences. Click a slice to filter.',
  heatmap: '<strong>Alert Start Time Distribution</strong> â€” When alerts tend to begin, by day of week and hour. Brighter cells mean more alerts started at that time. Helps identify recurring patterns like rush-hour disruptions or maintenance windows.',
  routeTable: '<strong>Route Analysis</strong> â€” Per-route stats including reliability grade (A-F based on severe alerts/day), alert frequency, top cause, and median duration. Click any row for details. Column headers are sortable.',
  totalAlerts: '<strong>Total Alerts</strong> â€” The count of unique service alerts in the filtered period, deduplicated by alert ID. The per-day rate divides this by calendar days, giving a sense of how disruptive an average day is.',
  mostAffected: '<strong>Most Affected Route</strong> â€” The route with the highest total alert count in the current filter. Its letter grade (A-F) reflects severe alerts per day. A route can have many alerts but a good grade if few are severe.',
  severeCard: '<strong>Severe Alerts</strong> â€” Alerts the MBTA flagged as high-impact disruptions (e.g., full suspensions, major delays). This is the key input to the reliability grade. More severe alerts per day means a worse grade for the route.',
  warningCard: '<strong>Warnings</strong> â€” Moderate-impact alerts such as partial service changes, short delays, or reduced frequency. These are disruptive but less so than Severe alerts. High warning counts signal chronic but manageable issues.',
  infoCard: '<strong>Info Alerts</strong> â€” Low-impact advisories such as planned service changes, elevator closures, or informational notices. These rarely affect your commute but are useful for trip planning.',
};

const helpPopup = document.getElementById('helpPopup');
document.addEventListener('keydown', e => {
  if ((e.key === 'Enter' || e.key === ' ') && e.target.closest('.help-icon')) {
    e.preventDefault(); e.target.click();
  }
});
document.addEventListener('click', e => {
  const icon = e.target.closest('.help-icon');
  if (icon) {
    const key = icon.dataset.help;
    if (!HELP_TEXT[key]) return;
    helpPopup.innerHTML = HELP_TEXT[key];
    helpPopup.style.display = 'block';
    const rect = icon.getBoundingClientRect();
    // Position below the icon
    let top = rect.bottom + 8;
    let left = rect.left - 60;
    // Keep on screen
    if (left + 340 > window.innerWidth) left = window.innerWidth - 350;
    if (left < 10) left = 10;
    if (top + 200 > window.innerHeight) top = rect.top - 8 - helpPopup.offsetHeight;
    helpPopup.style.top = top + 'px';
    helpPopup.style.left = left + 'px';
    e.stopPropagation();
    return;
  }
  // Click anywhere else closes it
  helpPopup.style.display = 'none';
});

// â”€â”€â”€â”€ Color Palettes â”€â”€â”€â”€
const CAUSE_COLORS = {
  'Unknown': '#8b8fa3',
  'Disabled Train': '#ff4d6a', 'Maintenance': '#ffd43b', 'Signal Problem': '#ff9f43',
  'Police Activity': '#b197fc', 'Medical Emergency': '#ff8787',
  'Switch Problem': '#e599f7', 'Power Problem': '#ffa94d',
  'Single Tracking': '#38bdf8', 'Accident': '#ff6b6b',
  'Fire Dept Activity': '#da77f2', 'Track Problem': '#c084fc',
  'Track Work': '#a78bfa', 'Weather': '#22d3ee',
  'Construction': '#69db7c', 'Traffic': '#67e8f9',
  'Fire': '#ef4444', 'Special Event': '#51cf66',
  'Heavy Ridership': '#94d82d', 'Mechanical Issue': '#f87171',
  'Speed Restriction': '#fb923c',
  'Technical Problem': '#ff4d6a', 'Other': '#a0a4b8',
};
const SEV_COLORS = { 'SEVERE': '#ff4d6a', 'WARNING': '#ff9f43', 'INFO': '#51cf66' };
const RT_COLORS = {
  'Bus': '#ff9f43', 'Subway': '#4f8cff', 'Commuter Rail': '#b197fc',
  'Green Line': '#51cf66', 'Ferry': '#22d3ee', 'Unspecified': '#8b8fa3', 'Other': '#a0a4b8',
};
const EFFECT_COLORS = {
  'Detour': '#ff9f43', 'Accessibility Issue': '#b197fc', 'Other': '#8b8fa3',
  'Stop Moved': '#22d3ee', 'Unknown': '#a0a4b8', 'Significant Delays': '#ff4d6a',
  'No Service': '#ff6b6b', 'Modified Service': '#ffd43b', 'Additional Service': '#51cf66',
  'Reduced Service': '#e599f7', 'Shuttle': '#38bdf8', 'Stop Closure': '#ff8787',
  'Station Closure': '#da77f2', 'Delay': '#ffa94d', 'Suspension': '#f87171',
  'Service Change': '#69db7c', 'Cancellation': '#ef4444', 'Track Change': '#a78bfa',
  'Schedule Change': '#67e8f9', 'Elevator Closure': '#c084fc', 'Escalator Closure': '#e879f9',
};
const GRADE_COLORS = {
  'A': '#51cf66', 'B': '#94d82d', 'C': '#ffd43b', 'D': '#ff9f43', 'F': '#ff4d6a',
};
const DOW_LABELS = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
const MONTH_SHORT = m => {
  const [,mm] = m.split('-');
  return ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'][parseInt(mm)-1];
};

function getColor(key, palette) { return palette[key] || '#8b8fa3'; }

// â”€â”€â”€â”€ Reliability Grade â”€â”€â”€â”€
// Based on severe alerts per day for the route
function getGrade(severePerDay) {
  if (severePerDay < 0.2) return 'A';
  if (severePerDay < 1.0) return 'B';
  if (severePerDay < 3.0) return 'C';
  if (severePerDay < 6.0) return 'D';
  return 'F';
}
function gradeSort(g) { return { 'A': 1, 'B': 2, 'C': 3, 'D': 4, 'F': 5 }[g] || 5; }

// â”€â”€â”€â”€ State â”€â”€â”€â”€
let DATA = null;
let filters = { routeType: '', route: '', cause: '', severity: '', monthFrom: '', monthTo: '' };
let charts = {};
let sortCol = 'count', sortDir = -1;
let selectedRoute = null;

let mapObj = null;
let mapLayers = {};

// â”€â”€â”€â”€ URL State â”€â”€â”€â”€
function readUrlFilters() {
  const p = new URLSearchParams(window.location.search);
  if (p.get('rt')) filters.routeType = p.get('rt');
  if (p.get('route')) filters.route = p.get('route');
  if (p.get('cause')) filters.cause = p.get('cause');
  if (p.get('sev')) filters.severity = p.get('sev');
  if (p.get('from')) filters.monthFrom = p.get('from');
  if (p.get('to')) filters.monthTo = p.get('to');
}
function pushFilterState() {
  const p = new URLSearchParams();
  if (filters.routeType) p.set('rt', filters.routeType);
  if (filters.route) p.set('route', filters.route);
  if (filters.cause) p.set('cause', filters.cause);
  if (filters.severity) p.set('sev', filters.severity);
  if (filters.monthFrom) p.set('from', filters.monthFrom);
  if (filters.monthTo) p.set('to', filters.monthTo);
  const qs = p.toString();
  const url = window.location.pathname + (qs ? '?' + qs : '');
  history.replaceState(null, '', url);
}

// â”€â”€â”€â”€ About Panel â”€â”€â”€â”€
document.getElementById('aboutBtn').addEventListener('click', () => {
  _modalTrigger = document.getElementById('aboutBtn');
  const overlay = document.getElementById('aboutOverlay');
  overlay.classList.add('show');
  trapFocus(overlay);
});
document.getElementById('aboutClose').addEventListener('click', () => {
  const overlay = document.getElementById('aboutOverlay');
  overlay.classList.remove('show');
  releaseFocus(overlay);
});
document.getElementById('aboutOverlay').addEventListener('click', e => {
  if (e.target === document.getElementById('aboutOverlay')) {
    const overlay = document.getElementById('aboutOverlay');
    overlay.classList.remove('show');
    releaseFocus(overlay);
  }
});

// â”€â”€â”€â”€ Init â”€â”€â”€â”€
readUrlFilters();
fetch('alerts_data.json').then(r => r.json()).then(data => {
  DATA = data;
  document.getElementById('loading').style.display = 'none';
  document.getElementById('dashboard').style.display = 'block';

  // Show data freshness
  if (data.generated || data.dataRange) {
    const meta = document.getElementById('dataMeta');
    const parts = [];
    if (data.dataRange) {
      const fmt = m => { const [y, mo] = m.split('-'); return ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'][+mo - 1] + ' ' + y; };
      parts.push('Data: ' + fmt(data.dataRange.from) + ' â€“ ' + fmt(data.dataRange.to));
    }
    if (data.generated) {
      parts.push('Generated: ' + new Date(data.generated).toLocaleDateString());
    }
    meta.textContent = parts.join(' | ');
  }

  populateFilters();
  // Apply URL filter state to dropdowns
  if (filters.routeType) document.getElementById('filterRouteType').value = filters.routeType;
  if (filters.route) document.getElementById('filterRoute').value = filters.route;
  if (filters.cause) document.getElementById('filterCause').value = filters.cause;
  if (filters.severity) document.getElementById('filterSeverity').value = filters.severity;
  if (filters.monthFrom) document.getElementById('filterMonthFrom').value = filters.monthFrom;
  if (filters.monthTo) document.getElementById('filterMonthTo').value = filters.monthTo;

  initMap();
  renderAll();
}).catch(err => {
  document.getElementById('loading').innerHTML =
    '<div class="error-state">Failed to load alert data.<br><span style="font-size:13px;color:var(--text-dim)">' +
    err.message + '</span></div>';
});

// â”€â”€â”€â”€ Helpers â”€â”€â”€â”€

// Get the right data source based on route type filter (#9 fix)
function getDataSource() {
  if (filters.routeType && DATA.byRouteType[filters.routeType]) {
    return DATA.byRouteType[filters.routeType];
  }
  return DATA;
}

// Total days in filtered month range
function getTotalDays(start, end) {
  let days = 0;
  for (let i = start; i <= end; i++) {
    days += DATA.daysPerMonth[i];
  }
  return days;
}

function getFilteredMonthIndices() {
  let start = 0, end = DATA.months.length - 1;
  if (filters.monthFrom) start = DATA.months.indexOf(filters.monthFrom);
  if (filters.monthTo) end = DATA.months.indexOf(filters.monthTo);
  if (start < 0) start = 0;
  if (end < 0) end = DATA.months.length - 1;
  if (start > end) [start, end] = [end, start];
  return { start, end, months: DATA.months.slice(start, end + 1) };
}

// Get a route's alert count for the filtered month range only
function getRouteFilteredCount(r, start, end) {
  let total = 0;
  DATA.months.forEach((m, i) => { if (i >= start && i <= end) total += (r.months[m] || 0); });
  return total;
}
// Get a route's severe count for the filtered month range only
function getRouteFilteredSevere(r, start, end) {
  if (r.monthlySev) {
    const vals = r.monthlySev['SEVERE'] || [];
    let total = 0;
    for (let i = start; i <= end; i++) total += (vals[i] || 0);
    return total;
  }
  return r.severe; // fallback to full-year
}

function getFilteredRoutes() {
  let routes = DATA.routeTable;
  if (filters.routeType) routes = routes.filter(r => r.type === filters.routeType);
  if (filters.route) routes = routes.filter(r => r.id === filters.route);
  return routes;
}

// â”€â”€â”€â”€ Filters â”€â”€â”€â”€
function populateFilters() {
  const rtSel = document.getElementById('filterRouteType');
  DATA.routeTypeNames.forEach(rt => {
    const o = document.createElement('option'); o.value = rt; o.textContent = rt; rtSel.appendChild(o);
  });
  const oU = document.createElement('option'); oU.value = 'Unspecified'; oU.textContent = 'Unspecified'; rtSel.appendChild(oU);

  // Route-level filter
  const rSel = document.getElementById('filterRoute');
  DATA.routeTable.forEach(r => {
    const o = document.createElement('option'); o.value = r.id; o.textContent = r.displayName || r.id; rSel.appendChild(o);
  });

  const cSel = document.getElementById('filterCause');
  DATA.causes.forEach(c => {
    const o = document.createElement('option'); o.value = c; o.textContent = c; cSel.appendChild(o);
  });

  const mfSel = document.getElementById('filterMonthFrom');
  const mtSel = document.getElementById('filterMonthTo');
  DATA.months.forEach(m => {
    const o1 = document.createElement('option'); o1.value = m; o1.textContent = MONTH_SHORT(m) + ' 2025';
    const o2 = document.createElement('option'); o2.value = m; o2.textContent = MONTH_SHORT(m) + ' 2025';
    mfSel.appendChild(o1); mtSel.appendChild(o2);
  });
}

document.getElementById('filterRouteType').addEventListener('change', e => {
  filters.routeType = e.target.value;
  // Clear route filter if route type changes (they may conflict)
  if (filters.route) {
    const r = DATA.routeTable.find(rt => rt.id === filters.route);
    if (r && filters.routeType && r.type !== filters.routeType) {
      filters.route = '';
      document.getElementById('filterRoute').value = '';
    }
  }
  renderAll();
});
document.getElementById('filterRoute').addEventListener('change', e => {
  filters.route = e.target.value;
  // Auto-set route type to match
  if (filters.route) {
    const r = DATA.routeTable.find(rt => rt.id === filters.route);
    if (r && !filters.routeType) {
      filters.routeType = r.type;
      document.getElementById('filterRouteType').value = r.type;
    }
  }
  renderAll();
});
document.getElementById('filterCause').addEventListener('change', e => { filters.cause = e.target.value; renderAll(); });
document.getElementById('filterSeverity').addEventListener('change', e => { filters.severity = e.target.value; renderAll(); });
document.getElementById('filterMonthFrom').addEventListener('change', e => { filters.monthFrom = e.target.value; renderAll(); });
document.getElementById('filterMonthTo').addEventListener('change', e => { filters.monthTo = e.target.value; renderAll(); });
document.getElementById('clearFilters').addEventListener('click', () => {
  filters = { routeType: '', route: '', cause: '', severity: '', monthFrom: '', monthTo: '' };
  document.getElementById('filterRouteType').value = '';
  document.getElementById('filterRoute').value = '';
  document.getElementById('filterCause').value = '';
  document.getElementById('filterSeverity').value = '';
  document.getElementById('filterMonthFrom').value = '';
  document.getElementById('filterMonthTo').value = '';
  renderAll();
});

function updateActiveFilters() {
  const container = document.getElementById('activeFilters');
  container.innerHTML = '';
  const active = [];
  if (filters.routeType) active.push({ key: 'routeType', label: 'Type: ' + filters.routeType, elId: 'filterRouteType' });
  if (filters.route) {
    const r = DATA.routeTable.find(rt => rt.id === filters.route);
    active.push({ key: 'route', label: 'Route: ' + (r ? (r.displayName || r.id) : filters.route), elId: 'filterRoute' });
  }
  if (filters.cause) active.push({ key: 'cause', label: 'Cause: ' + filters.cause, elId: 'filterCause' });
  if (filters.severity) active.push({ key: 'severity', label: 'Severity: ' + filters.severity, elId: 'filterSeverity' });
  if (filters.monthFrom || filters.monthTo) {
    const from = filters.monthFrom ? MONTH_SHORT(filters.monthFrom) : 'Jan';
    const to = filters.monthTo ? MONTH_SHORT(filters.monthTo) : 'Dec';
    active.push({ key: 'months', label: from + ' â€” ' + to });
  }
  active.forEach(f => {
    const tag = document.createElement('button');
    tag.className = 'filter-tag';
    tag.setAttribute('aria-label', 'Remove filter: ' + f.label);
    tag.innerHTML = `${f.label} <span class="x">&times;</span>`;
    tag.addEventListener('click', () => {
      if (f.key === 'months') {
        filters.monthFrom = ''; filters.monthTo = '';
        document.getElementById('filterMonthFrom').value = '';
        document.getElementById('filterMonthTo').value = '';
      } else {
        filters[f.key] = '';
        if (f.elId) document.getElementById(f.elId).value = '';
      }
      renderAll();
    });
    container.appendChild(tag);
  });
}

// â”€â”€â”€â”€ Render All â”€â”€â”€â”€
function renderAll() {
  pushFilterState();
  updateActiveFilters();
  updateChartVisibility();
  renderDataQualityBanner();
  renderSummaryCards();
  renderDuration();
  renderContextText();
  renderMapRoutes();
  renderTrendChart();
  renderCauseChart();
  renderEffectChart();
  renderSeverityChart();
  renderRouteTypeChart();
  renderHeatmap();
  renderRouteTable();
}

// â”€â”€â”€â”€ Conditional Chart Visibility â”€â”€â”€â”€
function updateChartVisibility() {
  const rt = filters.routeType;
  const cause = filters.cause;
  const sev = filters.severity;

  // Route Type chart: hide if a route type is already selected
  document.getElementById('routeTypePanel').style.display = rt ? 'none' : '';

  // Severity chart: hide if a severity is already selected
  document.getElementById('severityPanel').style.display = sev ? 'none' : '';

  // If both severity and route type hidden, hide the whole row
  const sevRtRow = document.getElementById('sevRtRow');
  if (rt && sev) {
    sevRtRow.style.display = 'none';
  } else if (rt || sev) {
    // One visible â€” switch to single column
    sevRtRow.style.display = 'grid';
    sevRtRow.style.gridTemplateColumns = '1fr';
  } else {
    sevRtRow.style.display = '';
    sevRtRow.style.gridTemplateColumns = '';
  }

  // Cause chart: hide if a cause is already selected (cause is now the second child)
  const causePanel = document.getElementById('causePanel');
  causePanel.style.display = cause ? 'none' : '';
  const ceRow = document.getElementById('causeEffectRow');
  if (cause) {
    ceRow.style.gridTemplateColumns = '1fr';
  } else {
    ceRow.style.gridTemplateColumns = '';
  }
}

// â”€â”€â”€â”€ Duration Panel â”€â”€â”€â”€
function renderDuration() {
  const src = getDataSource();
  const dur = src.duration || DATA.duration;
  const container = document.getElementById('durationContent');

  if (!dur || dur.count === 0) {
    document.getElementById('durationPanel').style.display = 'none';
    return;
  }
  document.getElementById('durationPanel').style.display = '';

  function fmtHours(h) {
    if (h < 1) return Math.round(h * 60) + ' min';
    if (h < 24) return h.toFixed(1) + ' hrs';
    return (h / 24).toFixed(1) + ' days';
  }

  const rtLabel = filters.routeType || 'all rail';

  // Build per-route duration mini-table for filtered routes
  const routes = getFilteredRoutes().filter(r => r.duration && r.duration.count > 0);
  const sorted = [...routes].sort((a, b) => b.duration.median - a.duration.median).slice(0, 6);

  container.innerHTML = `
    <div style="flex:0 0 auto">
      <div style="color:var(--text-dim);font-size:12px;text-transform:uppercase;letter-spacing:0.5px;margin-bottom:6px">${rtLabel} alerts (${dur.count.toLocaleString()} with duration data)</div>
      <div style="display:flex;gap:24px;flex-wrap:wrap">
        <div>
          <div style="font-size:28px;font-weight:700;color:var(--accent)">${fmtHours(dur.median)}</div>
          <div style="font-size:12px;color:var(--text-dim)">Median Duration</div>
        </div>
        <div>
          <div style="font-size:28px;font-weight:700;color:var(--orange)">${fmtHours(dur.mean)}</div>
          <div style="font-size:12px;color:var(--text-dim)">Mean Duration</div>
        </div>
        <div>
          <div style="font-size:28px;font-weight:700;color:var(--red)">${fmtHours(dur.p90)}</div>
          <div style="font-size:12px;color:var(--text-dim)">90th Percentile</div>
        </div>
      </div>
    </div>
    <div style="flex:1;min-width:300px">
      <div style="font-size:12px;color:var(--text-dim);text-transform:uppercase;letter-spacing:0.5px;margin-bottom:6px">Longest Median Disruptions</div>
      <div style="display:grid;grid-template-columns:1fr auto auto;gap:4px 16px;font-size:13px">
        <div style="color:var(--text-dim);font-size:11px;font-weight:600">Route</div>
        <div style="color:var(--text-dim);font-size:11px;font-weight:600">Median</div>
        <div style="color:var(--text-dim);font-size:11px;font-weight:600">90th %ile</div>
        ${sorted.map(r => `
          <div><strong>${r.displayName || r.id}</strong></div>
          <div style="color:var(--accent)">${fmtHours(r.duration.median)}</div>
          <div style="color:var(--red)">${fmtHours(r.duration.p90)}</div>
        `).join('')}
      </div>
    </div>
  `;
}

// â”€â”€â”€â”€ #12: Data Quality Banner â”€â”€â”€â”€
function renderDataQualityBanner() {
  const src = getDataSource();
  const totals = src.causeTotals || DATA.causeTotals;
  const unknownCount = totals['Unknown'] || 0;
  const totalCauses = Object.values(totals).reduce((a, b) => a + b, 0);
  const pct = totalCauses > 0 ? (unknownCount / totalCauses * 100) : 0;

  const banner = document.getElementById('dataQualityBanner');
  if (pct > 15) {
    banner.style.display = 'block';
    const rtLabel = filters.routeType ? filters.routeType + ' ' : '';
    banner.innerHTML = `<strong>Data quality note:</strong> ${pct.toFixed(0)}% of ${rtLabel}alert causes are unrecorded by the MBTA. The <em>effect</em> data (Delay, Track Change, etc.) is 100% classified and more reliable for analysis. Cause breakdowns below exclude "Unknown" to show the ${(100-pct).toFixed(0)}% with identified causes.`;
  } else {
    banner.style.display = 'none';
  }
}

// â”€â”€â”€â”€ Summary Cards (#2: alerts/day rate) â”€â”€â”€â”€
function renderSummaryCards() {
  const { start, end } = getFilteredMonthIndices();
  const days = getTotalDays(start, end);
  const routes = getFilteredRoutes();

  let totalAlerts = 0;
  const routeSums = {};
  routes.forEach(r => {
    DATA.months.forEach((m, i) => {
      if (i < start || i > end) return;
      const c = r.months[m] || 0;
      totalAlerts += c;
      routeSums[r.id] = (routeSums[r.id] || 0) + c;
    });
  });

  const topRoute = Object.entries(routeSums).sort((a, b) => b[1] - a[1])[0];
  const alertsPerDay = days > 0 ? (totalAlerts / days) : 0;

  // Severity from filtered routes, sliced by month range
  let sevTotal = { SEVERE: 0, WARNING: 0, INFO: 0 };
  routes.forEach(r => {
    if (r.monthlySev) {
      ['SEVERE', 'WARNING', 'INFO'].forEach(sev => {
        const vals = r.monthlySev[sev] || [];
        for (let i = start; i <= end; i++) sevTotal[sev] += (vals[i] || 0);
      });
    } else {
      // Fallback for data without monthlySev
      sevTotal.SEVERE += r.severe; sevTotal.WARNING += r.warning; sevTotal.INFO += r.info;
    }
  });
  const sevTotalSum = sevTotal.SEVERE + sevTotal.WARNING + sevTotal.INFO;

  // Top route grade
  let topRouteGrade = '';
  if (topRoute) {
    const topR = routes.find(r => r.id === topRoute[0]);
    if (topR) {
      const sevPerDay = days > 0 ? topR.severe / days : 0;
      topRouteGrade = getGrade(sevPerDay);
    }
  }

  const container = document.getElementById('summaryCards');
  container.innerHTML = `
    <div class="card">
      <div class="label">Total Alerts <span class="help-icon" tabindex="0" role="button" data-help="totalAlerts">?</span></div>
      <div class="value">${totalAlerts.toLocaleString()}</div>
      <div class="sub"><strong>${alertsPerDay.toFixed(1)}</strong> per day across ${routes.length} routes</div>
      <div class="bar" style="background:var(--accent)"></div>
    </div>
    <div class="card">
      <div class="label">Most Affected Route <span class="help-icon" tabindex="0" role="button" data-help="mostAffected">?</span></div>
      <div class="value">${topRoute ? (() => { const tr = routes.find(x => x.id === topRoute[0]); return (tr && tr.displayName) || topRoute[0]; })() : 'â€”'} ${topRouteGrade ? `<span class="grade-badge" style="background:${GRADE_COLORS[topRouteGrade]}22;color:${GRADE_COLORS[topRouteGrade]};font-size:16px;vertical-align:middle">${topRouteGrade}</span>` : ''}</div>
      <div class="sub">${topRoute ? (topRoute[1] / days).toFixed(1) + ' alerts/day (' + topRoute[1].toLocaleString() + ' total)' : ''}</div>
      <div class="bar" style="background:var(--red)"></div>
    </div>
    <div class="card">
      <div class="label">Severe Alerts <span class="help-icon" tabindex="0" role="button" data-help="severeCard">?</span></div>
      <div class="value" style="color:var(--red)">${sevTotal.SEVERE.toLocaleString()}</div>
      <div class="sub">${sevTotalSum ? (sevTotal.SEVERE / sevTotalSum * 100).toFixed(1) : 0}% of total &middot; ${days > 0 ? (sevTotal.SEVERE / days).toFixed(1) : 0}/day</div>
      <div class="bar" style="background:var(--red)"></div>
    </div>
    <div class="card">
      <div class="label">Warnings <span class="help-icon" tabindex="0" role="button" data-help="warningCard">?</span></div>
      <div class="value" style="color:var(--orange)">${sevTotal.WARNING.toLocaleString()}</div>
      <div class="sub">${sevTotalSum ? (sevTotal.WARNING / sevTotalSum * 100).toFixed(1) : 0}% of total &middot; ${days > 0 ? (sevTotal.WARNING / days).toFixed(1) : 0}/day</div>
      <div class="bar" style="background:var(--orange)"></div>
    </div>
    <div class="card">
      <div class="label">Info <span class="help-icon" tabindex="0" role="button" data-help="infoCard">?</span></div>
      <div class="value" style="color:var(--green)">${sevTotal.INFO.toLocaleString()}</div>
      <div class="sub">${sevTotalSum ? (sevTotal.INFO / sevTotalSum * 100).toFixed(1) : 0}% of total</div>
      <div class="bar" style="background:var(--green)"></div>
    </div>
  `;
}

// â”€â”€â”€â”€ #8: Context Text â”€â”€â”€â”€
function renderContextText() {
  const { start, end } = getFilteredMonthIndices();
  const days = getTotalDays(start, end);
  const routes = getFilteredRoutes();
  if (!routes.length || days === 0) {
    document.getElementById('contextText').style.display = 'none';
    return;
  }
  document.getElementById('contextText').style.display = 'block';

  // Compute filtered counts per route, sort by filtered count
  const withFiltered = routes.map(r => ({
    ...r,
    _fc: getRouteFilteredCount(r, start, end),
    _fs: getRouteFilteredSevere(r, start, end),
  }));
  const sorted = withFiltered.sort((a, b) => b._fc - a._fc);
  const worst = sorted[0];
  const best = sorted[sorted.length - 1];
  const worstPerDay = days > 0 ? (worst._fc / days).toFixed(1) : '0';
  const worstSevPerDay = days > 0 ? (worst._fs / days).toFixed(1) : '0';
  const bestPerDay = days > 0 ? (best._fc / days).toFixed(1) : '0';

  const totalAlerts = sorted.reduce((sum, r) => sum + r._fc, 0);
  const avgPerRoute = days > 0 ? (totalAlerts / routes.length / days).toFixed(1) : '0';

  const rtLabel = filters.routeType ? filters.routeType : 'all';
  const monthLabel = start === 0 && end === 11
    ? 'all of 2025'
    : `${MONTH_SHORT(DATA.months[start])}${start !== end ? 'â€“' + MONTH_SHORT(DATA.months[end]) : ''} 2025`;

  const worstGrade = getGrade(days > 0 ? worst._fs / days : 0);
  const bestGrade = getGrade(days > 0 ? best._fs / days : 0);

  // Duration context
  const src = getDataSource();
  const dur = src.duration || DATA.duration;
  const durText = dur && dur.count > 0
    ? ` The typical alert lasted <span class="highlight">${dur.median < 1 ? Math.round(dur.median * 60) + ' minutes' : dur.median.toFixed(1) + ' hours'}</span> (median), with the worst 10% lasting ${dur.p90 < 1 ? Math.round(dur.p90 * 60) + '+ minutes' : dur.p90.toFixed(1) + '+ hours'}.`
    : '';

  document.getElementById('contextText').innerHTML =
    `Over <strong>${monthLabel}</strong> (${days} days), across <strong>${routes.length} ${rtLabel} routes</strong>, ` +
    `the average route saw <span class="highlight">${avgPerRoute} alerts/day</span>. ` +
    `The most disrupted route was <span class="bad">${worst.displayName || worst.id}</span> (${worst.type}) at ` +
    `<span class="bad">${worstPerDay} alerts/day</span>, including ${worstSevPerDay} severe/day ` +
    `(grade <span style="color:${GRADE_COLORS[worstGrade]};font-weight:700">${worstGrade}</span>). ` +
    `The least disrupted was <span class="highlight">${best.displayName || best.id}</span> at ${bestPerDay} alerts/day ` +
    `(grade <span style="color:${GRADE_COLORS[bestGrade]};font-weight:700">${bestGrade}</span>).` + durText;
}

// â”€â”€â”€â”€ Map â”€â”€â”€â”€
function initMap() {
  mapObj = L.map('map', {
    center: [42.36, -71.06],
    zoom: 10,
    zoomControl: true,
  });
  const theme = getEffectiveTheme();
  const tileUrl = theme === 'light'
    ? 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png'
    : 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png';
  mapTileLayer = L.tileLayer(tileUrl, {
    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OSM</a> &copy; <a href="https://carto.com/">CARTO</a>',
    subdomains: 'abcd',
    maxZoom: 19,
  }).addTo(mapObj);
}

function renderMapRoutes() {
  if (!mapObj || !DATA.routeShapes) return;

  // Clear existing layers
  Object.values(mapLayers).forEach(layer => mapObj.removeLayer(layer));
  mapLayers = {};

  const { start, end } = getFilteredMonthIndices();
  const days = getTotalDays(start, end);
  const routes = getFilteredRoutes();
  const routeIndex = {};
  routes.forEach(r => { routeIndex[r.id] = r; });

  DATA.routeShapes.features.forEach(feature => {
    const routeId = feature.properties.routeId;
    const routeData = routeIndex[routeId];
    if (!routeData) return; // Route filtered out or not in our table

    const filteredCount = getRouteFilteredCount(routeData, start, end);
    const filteredSevere = getRouteFilteredSevere(routeData, start, end);
    const sevPerDay = days > 0 ? filteredSevere / days : 0;
    const grade = getGrade(sevPerDay);
    const baseColor = routeData.color || feature.properties.color;
    const perDay = days > 0 ? (filteredCount / days).toFixed(1) : '0';

    // Thicker + more opaque = worse grade
    const weightMap = { 'A': 3, 'B': 4, 'C': 5, 'D': 6, 'F': 8 };
    const opacityMap = { 'A': 0.5, 'B': 0.6, 'C': 0.75, 'D': 0.85, 'F': 1.0 };
    const style = {
      color: baseColor,
      weight: weightMap[grade] || 4,
      opacity: opacityMap[grade] || 0.7,
    };

    const layer = L.geoJSON(feature, {
      style: () => style,
    });

    // Popup
    const durInfo = routeData.duration && routeData.duration.count > 0
      ? `<br>Median duration: <strong>${routeData.duration.median < 1 ? Math.round(routeData.duration.median * 60) + ' min' : routeData.duration.median.toFixed(1) + ' hrs'}</strong>`
      : '';
    layer.bindPopup(`
      <div class="route-popup-title">${routeData.displayName || routeId}</div>
      <span class="route-popup-grade" style="background:${GRADE_COLORS[grade]}22;color:${GRADE_COLORS[grade]}">${grade}</span>
      <span style="color:var(--text-dim);font-size:12px;margin-left:6px">${routeData.type}</span>
      <div class="route-popup-stats">
        <strong>${perDay}</strong> alerts/day &middot;
        <strong>${filteredCount.toLocaleString()}</strong> total<br>
        <strong>${sevPerDay.toFixed(1)}</strong> severe/day &middot;
        Top cause: <strong>${routeData.topCause}</strong>${durInfo}
      </div>
    `, { maxWidth: 280, className: '' });

    // Hover: thicken line
    layer.on('mouseover', () => {
      layer.setStyle({ weight: style.weight + 4, opacity: 1 });
      layer.bringToFront();
    });
    layer.on('mouseout', () => {
      if (selectedRoute !== routeId) {
        layer.setStyle(style);
      }
    });

    // Click: select route, scroll to table row
    layer.on('click', () => {
      // Deselect previous
      if (selectedRoute && mapLayers[selectedRoute]) {
        const prevRoute = routeIndex[selectedRoute];
        if (prevRoute) {
          const prevGrade = getGrade(days > 0 ? prevRoute.severe / days : 0);
          mapLayers[selectedRoute].setStyle({
            color: prevRoute.color,
            weight: weightMap[prevGrade] || 4,
            opacity: opacityMap[prevGrade] || 0.7,
          });
        }
      }
      selectedRoute = routeId;
      renderRouteTable();
    });

    layer.addTo(mapObj);
    mapLayers[routeId] = layer;
  });

  renderMapLegend();
}

function renderMapLegend() {
  const legend = document.getElementById('mapLegend');
  const items = [
    { label: 'Red Line', color: '#DA291C' },
    { label: 'Orange Line', color: '#ED8B00' },
    { label: 'Blue Line', color: '#003DA5' },
    { label: 'Green Line', color: '#00843D' },
    { label: 'Commuter Rail', color: '#80276C' },
  ];
  legend.innerHTML = items.map(i => `
    <div class="legend-item">
      <div class="legend-swatch" style="background:${i.color}"></div>
      <span>${i.label}</span>
    </div>
  `).join('') + `<div class="legend-item legend-note">Line thickness = reliability grade (severe alerts/day)</div>`;
}

// â”€â”€â”€â”€ Monthly Trend (#9: uses filtered data source) â”€â”€â”€â”€
let trendMode = 'cause';
document.getElementById('trendToggle').addEventListener('click', e => {
  if (!e.target.classList.contains('toggle-btn')) return;
  document.querySelectorAll('#trendToggle .toggle-btn').forEach(b => b.classList.remove('active'));
  e.target.classList.add('active');
  trendMode = e.target.dataset.mode;
  renderTrendChart();
});

function renderTrendChart() {
  const { start, end, months } = getFilteredMonthIndices();
  const src = getDataSource();

  // Update trend chart title based on mode
  const trendTitleEl = document.getElementById('trendTitleText');
  if (trendMode === 'cause') {
    const totals = src.causeTotals || DATA.causeTotals;
    const unknownCount = totals['Unknown'] || 0;
    const total = Object.values(totals).reduce((a, b) => a + b, 0);
    const knownPct = total > 0 ? ((total - unknownCount) / total * 100).toFixed(0) : '100';
    trendTitleEl.innerHTML = 'Monthly Alert Trend <span style="font-weight:400;color:var(--text-dim);font-size:12px">(known causes only â€” ~' + knownPct + '% of alerts)</span>';
  } else {
    trendTitleEl.textContent = 'Monthly Alert Trend';
  }

  // Hide Route Type toggle when a route type filter is active
  const rtToggle = document.querySelector('#trendToggle [data-mode="routeType"]');
  if (rtToggle) rtToggle.style.display = filters.routeType ? 'none' : '';
  // If current mode is routeType but that's now hidden, switch to cause
  let mode = trendMode;
  if (mode === 'routeType' && filters.routeType) {
    mode = 'cause';
    trendMode = 'cause';
    document.querySelectorAll('#trendToggle .toggle-btn').forEach(b => {
      b.classList.toggle('active', b.dataset.mode === 'cause');
    });
  }

  let sourceData, categories, colorMap;

  if (mode === 'cause') {
    sourceData = src.monthlyCause;
    categories = (src.causes || DATA.causes).filter(c => c !== 'Unknown' && c !== 'Other');
    colorMap = CAUSE_COLORS;
  } else if (mode === 'severity') {
    sourceData = src.monthlySeverity; categories = ['SEVERE', 'WARNING', 'INFO']; colorMap = SEV_COLORS;
  } else if (mode === 'routeType') {
    sourceData = DATA.monthlyRouteType; categories = Object.keys(DATA.monthlyRouteType); colorMap = RT_COLORS;
  } else {
    sourceData = src.monthlyEffect; categories = src.effects || DATA.effects; colorMap = EFFECT_COLORS;
  }

  const catTotals = categories.map(c => ({
    cat: c,
    total: (sourceData[c] || []).slice(start, end + 1).reduce((a, b) => a + b, 0)
  })).sort((a, b) => b.total - a.total);

  const topCats = catTotals.slice(0, 8).map(c => c.cat);
  const otherTotal = catTotals.slice(8).reduce((acc, c) => {
    const vals = (sourceData[c.cat] || []).slice(start, end + 1);
    vals.forEach((v, i) => { acc[i] = (acc[i] || 0) + v; });
    return acc;
  }, []);

  const datasets = topCats.map(cat => ({
    label: cat,
    data: (sourceData[cat] || []).slice(start, end + 1),
    backgroundColor: getColor(cat, colorMap),
    borderRadius: 3,
  }));

  if (otherTotal.length && otherTotal.some(v => v > 0)) {
    datasets.push({ label: 'Other', data: otherTotal, backgroundColor: getComputedStyle(document.documentElement).getPropertyValue('--text-dim').trim(), borderRadius: 3 });
  }

  const cc = getChartColors();
  if (charts.trend) charts.trend.destroy();
  charts.trend = new Chart(document.getElementById('trendChart'), {
    type: 'bar',
    data: { labels: months.map(MONTH_SHORT), datasets },
    options: {
      responsive: true, maintainAspectRatio: false,
      plugins: {
        legend: { position: 'bottom', labels: { color: cc.tick, boxWidth: 12, padding: 12, font: { size: 11 } } },
        tooltip: { mode: 'index', intersect: false },
      },
      scales: {
        x: { stacked: true, ticks: { color: cc.tick }, grid: { color: cc.grid } },
        y: { stacked: true, ticks: { color: cc.tick }, grid: { color: cc.grid } },
      },
      onClick: (_, elems) => {
        if (elems.length) {
          const m = months[elems[0].index];
          filters.monthFrom = m; filters.monthTo = m;
          document.getElementById('filterMonthFrom').value = m;
          document.getElementById('filterMonthTo').value = m;
          renderAll();
        }
      },
    },
  });
}

// â”€â”€â”€â”€ Cause Chart (#9: uses filtered data source) â”€â”€â”€â”€
function renderCauseChart() {
  const { start, end } = getFilteredMonthIndices();
  const src = getDataSource();
  const causes = src.causes || DATA.causes;
  const monthlyCause = src.monthlyCause;

  // Update cause subtitle with actual percentage
  const totals = src.causeTotals || DATA.causeTotals;
  const unknownCount = totals['Unknown'] || 0;
  const totalCauses = Object.values(totals).reduce((a, b) => a + b, 0);
  const knownPct = totalCauses > 0 ? ((totalCauses - unknownCount) / totalCauses * 100).toFixed(0) : '100';
  const sub = document.getElementById('causeSubtitle');
  if (sub) sub.textContent = '(known causes only â€” ~' + knownPct + '% of alerts)';

  const causeData = {};
  causes.forEach(c => {
    const vals = (monthlyCause[c] || []).slice(start, end + 1);
    causeData[c] = vals.reduce((a, b) => a + b, 0);
  });
  // Exclude Unknown/Other from cause chart â€” they dominate but aren't informative
  const sorted = Object.entries(causeData).filter(([k, v]) => v > 0 && k !== 'Unknown' && k !== 'Other').sort((a, b) => b[1] - a[1]);

  const cc2 = getChartColors();
  if (charts.cause) charts.cause.destroy();
  charts.cause = new Chart(document.getElementById('causeChart'), {
    type: 'bar',
    data: {
      labels: sorted.map(([k]) => k),
      datasets: [{ data: sorted.map(([, v]) => v), backgroundColor: sorted.map(([k]) => getColor(k, CAUSE_COLORS)), borderRadius: 6 }],
    },
    options: {
      indexAxis: 'y', responsive: true, maintainAspectRatio: false,
      plugins: { legend: { display: false } },
      scales: {
        x: { ticks: { color: cc2.tick }, grid: { color: cc2.grid } },
        y: { ticks: { color: cc2.label, font: { size: 11 } }, grid: { display: false } },
      },
      onClick: (_, elems) => {
        if (elems.length) {
          filters.cause = sorted[elems[0].index][0];
          document.getElementById('filterCause').value = filters.cause;
          renderAll();
        }
      },
    },
  });
}

// â”€â”€â”€â”€ Effect Chart (#9: uses filtered data source) â”€â”€â”€â”€
function renderEffectChart() {
  const { start, end } = getFilteredMonthIndices();
  const src = getDataSource();
  const effects = src.effects || DATA.effects;
  const monthlyEffect = src.monthlyEffect;

  const effectData = {};
  effects.forEach(e => {
    const vals = (monthlyEffect[e] || []).slice(start, end + 1);
    effectData[e] = vals.reduce((a, b) => a + b, 0);
  });
  const sorted = Object.entries(effectData).filter(([k, v]) => v > 0 && k !== 'Unknown' && k !== 'Other').sort((a, b) => b[1] - a[1]).slice(0, 10);

  const cc3 = getChartColors();
  if (charts.effect) charts.effect.destroy();
  charts.effect = new Chart(document.getElementById('effectChart'), {
    type: 'bar',
    data: {
      labels: sorted.map(([k]) => k),
      datasets: [{ data: sorted.map(([, v]) => v), backgroundColor: sorted.map(([k]) => getColor(k, EFFECT_COLORS)), borderRadius: 6 }],
    },
    options: {
      indexAxis: 'y', responsive: true, maintainAspectRatio: false,
      plugins: { legend: { display: false } },
      scales: {
        x: { ticks: { color: cc3.tick }, grid: { color: cc3.grid } },
        y: { ticks: { color: cc3.label, font: { size: 11 } }, grid: { display: false } },
      },
    },
  });
}

// â”€â”€â”€â”€ Severity Chart (#9: uses filtered data source) â”€â”€â”€â”€
function renderSeverityChart() {
  const { start, end } = getFilteredMonthIndices();
  const src = getDataSource();
  const sevData = {};
  ['SEVERE', 'WARNING', 'INFO'].forEach(s => {
    const vals = (src.monthlySeverity[s] || []).slice(start, end + 1);
    sevData[s] = vals.reduce((a, b) => a + b, 0);
  });

  const cc4 = getChartColors();
  if (charts.severity) charts.severity.destroy();
  charts.severity = new Chart(document.getElementById('severityChart'), {
    type: 'doughnut',
    data: {
      labels: ['Severe', 'Warning', 'Info'],
      datasets: [{
        data: [sevData.SEVERE, sevData.WARNING, sevData.INFO],
        backgroundColor: [SEV_COLORS.SEVERE, SEV_COLORS.WARNING, SEV_COLORS.INFO],
        borderWidth: 0, hoverOffset: 8,
      }],
    },
    options: {
      responsive: true, maintainAspectRatio: false, cutout: '60%',
      plugins: {
        legend: { position: 'bottom', labels: { color: cc4.tick, padding: 16, font: { size: 12 } } },
        tooltip: {
          callbacks: {
            label: ctx => {
              const total = ctx.dataset.data.reduce((a, b) => a + b, 0);
              return `${ctx.label}: ${ctx.raw.toLocaleString()} (${total > 0 ? (ctx.raw / total * 100).toFixed(1) : 0}%)`;
            }
          }
        },
      },
      onClick: (_, elems) => {
        if (elems.length) {
          const sev = ['SEVERE', 'WARNING', 'INFO'][elems[0].index];
          filters.severity = sev;
          document.getElementById('filterSeverity').value = sev;
          renderAll();
        }
      },
    },
  });
}

// â”€â”€â”€â”€ Route Type Chart (always global â€” it's the filter selector) â”€â”€â”€â”€
function renderRouteTypeChart() {
  const { start, end } = getFilteredMonthIndices();
  const rtData = {};
  Object.keys(DATA.monthlyRouteType).forEach(rt => {
    const vals = (DATA.monthlyRouteType[rt] || []).slice(start, end + 1);
    rtData[rt] = vals.reduce((a, b) => a + b, 0);
  });
  const sorted = Object.entries(rtData).filter(([, v]) => v > 0).sort((a, b) => b[1] - a[1]);

  const cc5 = getChartColors();
  if (charts.routeType) charts.routeType.destroy();
  charts.routeType = new Chart(document.getElementById('routeTypeChart'), {
    type: 'doughnut',
    data: {
      labels: sorted.map(([k]) => k),
      datasets: [{
        data: sorted.map(([, v]) => v),
        backgroundColor: sorted.map(([k]) => getColor(k, RT_COLORS)),
        borderWidth: 0, hoverOffset: 8,
        offset: sorted.map(([k]) => filters.routeType === k ? 12 : 0),
      }],
    },
    options: {
      responsive: true, maintainAspectRatio: false, cutout: '60%',
      plugins: {
        legend: { position: 'bottom', labels: { color: cc5.tick, padding: 16, font: { size: 12 } } },
        tooltip: {
          callbacks: {
            label: ctx => {
              const total = ctx.dataset.data.reduce((a, b) => a + b, 0);
              return `${ctx.label}: ${ctx.raw.toLocaleString()} (${total > 0 ? (ctx.raw / total * 100).toFixed(1) : 0}%)`;
            }
          }
        },
      },
      onClick: (_, elems) => {
        if (elems.length) {
          const rt = sorted[elems[0].index][0];
          // Toggle: clicking the same one deselects
          if (filters.routeType === rt) {
            filters.routeType = '';
            document.getElementById('filterRouteType').value = '';
          } else {
            filters.routeType = rt;
            document.getElementById('filterRouteType').value = rt;
          }
          renderAll();
        }
      },
    },
  });
}

// â”€â”€â”€â”€ Heatmap (#9: uses filtered data source) â”€â”€â”€â”€
function renderHeatmap() {
  const container = document.getElementById('heatmapContainer');
  const src = getDataSource();
  const grid = src.heatmap;
  const maxVal = Math.max(...grid.flat(), 1);

  let html = '<div class="heatmap-grid">';
  html += '<div></div>';
  for (let h = 0; h < 24; h++) {
    const label = h === 0 ? '12a' : h < 12 ? h + 'a' : h === 12 ? '12p' : (h - 12) + 'p';
    html += `<div class="col-label">${label}</div>`;
  }
  const isLight = getEffectiveTheme() === 'light';
  for (let d = 0; d < 7; d++) {
    html += `<div class="row-label">${DOW_LABELS[d]}</div>`;
    for (let h = 0; h < 24; h++) {
      const val = grid[d][h];
      const intensity = val / maxVal;
      let bg;
      if (isLight) {
        // Light: transparent blue â†’ warm red
        const alpha = 0.15 + intensity * 0.85;
        bg = `rgba(${Math.round(37 + (220-37)*intensity)},${Math.round(99 + (60-99)*intensity)},${Math.round(235 + (100-235)*intensity)},${alpha})`;
      } else {
        // Dark: transparent blue â†’ red
        const r = Math.round(79 + (255 - 79) * intensity);
        const g = Math.round(140 + (77 - 140) * intensity);
        const b = Math.round(255 + (106 - 255) * intensity);
        const alpha = 0.1 + intensity * 0.9;
        bg = `rgba(${r},${g},${b},${alpha})`;
      }
      html += `<div class="cell" style="background:${bg}" data-dow="${d}" data-hour="${h}" data-val="${val}">${val > maxVal * 0.3 ? val : ''}</div>`;
    }
  }
  html += '</div>';
  container.innerHTML = html;

  container.querySelectorAll('.cell').forEach(cell => {
    cell.addEventListener('mouseenter', e => {
      const d = parseInt(e.target.dataset.dow);
      const h = parseInt(e.target.dataset.hour);
      const v = parseInt(e.target.dataset.val);
      const timeLabel = h === 0 ? '12:00 AM' : h < 12 ? h + ':00 AM' : h === 12 ? '12:00 PM' : (h-12) + ':00 PM';
      showTooltip(e, DOW_LABELS[d] + ' ' + timeLabel, v.toLocaleString() + ' alerts', '');
    });
    cell.addEventListener('mouseleave', hideTooltip);
  });
}

// â”€â”€â”€â”€ Route Table (#2: alerts/day, #4: grade) â”€â”€â”€â”€
let routeSearchTerm = '';
document.getElementById('routeSearch').addEventListener('input', e => {
  routeSearchTerm = e.target.value.toLowerCase();
  renderRouteTable();
});

document.querySelectorAll('#routeTable th[data-col]').forEach(th => {
  th.addEventListener('click', () => {
    const col = th.dataset.col;
    if (sortCol === col) sortDir *= -1;
    else { sortCol = col; sortDir = -1; }
    renderRouteTable();
  });
});

// â”€â”€â”€â”€ Export CSV â”€â”€â”€â”€
document.getElementById('exportCsv').addEventListener('click', () => {
  const { start, end } = getFilteredMonthIndices();
  const days = getTotalDays(start, end);
  let routes = getFilteredRoutes();
  if (routeSearchTerm) routes = routes.filter(r => r.id.toLowerCase().includes(routeSearchTerm) || (r.displayName && r.displayName.toLowerCase().includes(routeSearchTerm)));

  const rows = [['Route', 'Type', 'Grade', 'Alerts/Day', 'Total', 'Avg Sev', 'Top Cause', 'Top Effect', 'Median Duration', 'Severe%', 'Warning%', 'Info%']];
  routes.forEach(r => {
    const fc = getRouteFilteredCount(r, start, end);
    const fs = getRouteFilteredSevere(r, start, end);
    const perDay = days > 0 ? (fc / days).toFixed(2) : '0';
    const sevPerDay = days > 0 ? (fs / days) : 0;
    const grade = getGrade(sevPerDay);
    const total = r.severe + r.warning + r.info;
    const sp = total > 0 ? (r.severe / total * 100).toFixed(1) : '0';
    const wp = total > 0 ? (r.warning / total * 100).toFixed(1) : '0';
    const ip = total > 0 ? (r.info / total * 100).toFixed(1) : '0';
    const medDur = r.duration && r.duration.count > 0 ? r.duration.median.toFixed(1) + 'h' : '';
    rows.push([r.displayName || r.id, r.type, grade, perDay, fc, r.avgSev.toFixed(2), r.topCause, r.topEffect, medDur, sp, wp, ip]);
  });

  const csv = rows.map(r => r.map(c => '"' + String(c).replace(/"/g, '""') + '"').join(',')).join('\n');
  const blob = new Blob([csv], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'mbta_routes_export.csv';
  document.body.appendChild(a); a.click(); document.body.removeChild(a);
  URL.revokeObjectURL(url);
});

function renderRouteTable() {
  const { start, end } = getFilteredMonthIndices();
  const days = getTotalDays(start, end);
  let routes = getFilteredRoutes();
  if (routeSearchTerm) {
    routes = routes.filter(r => r.id.toLowerCase().includes(routeSearchTerm) || (r.displayName && r.displayName.toLowerCase().includes(routeSearchTerm)));
  }

  // Compute derived fields using filtered month range
  const enriched = routes.map(r => {
    const fc = getRouteFilteredCount(r, start, end);
    const fs = getRouteFilteredSevere(r, start, end);
    const perDay = days > 0 ? fc / days : 0;
    const sevPerDay = days > 0 ? fs / days : 0;
    const grade = getGrade(sevPerDay);
    const medDur = r.duration && r.duration.count > 0 ? r.duration.median : 0;
    return { ...r, perDay, sevPerDay, grade, medDur, _fc: fc };
  });

  // Sort
  document.querySelectorAll('#routeTable th[data-col]').forEach(th => {
    const arrow = th.querySelector('.sort-arrow');
    arrow.textContent = th.dataset.col === sortCol ? (sortDir > 0 ? '\u25B2' : '\u25BC') : '';
  });

  enriched.sort((a, b) => {
    let va = a[sortCol], vb = b[sortCol];
    if (sortCol === 'grade') { va = gradeSort(va); vb = gradeSort(vb); }
    if (typeof va === 'string') return sortDir * va.localeCompare(vb);
    return sortDir * (va - vb);
  });

  const tbody = document.getElementById('routeTableBody');
  tbody.innerHTML = enriched.map(r => {
    const total = r.severe + r.warning + r.info;
    const sp = total > 0 ? (r.severe / total * 100) : 0;
    const wp = total > 0 ? (r.warning / total * 100) : 0;
    const typeClass = r.type.includes('Bus') ? 'bus'
      : r.type.includes('Subway') ? 'subway'
      : r.type.includes('Commuter') ? 'commuter'
      : r.type.includes('Green') ? 'light'
      : r.type.includes('Ferry') ? 'ferry' : 'other';
    return `<tr data-route="${r.id}" class="${selectedRoute === r.id ? 'selected' : ''}">
      <td><strong>${r.displayName || r.id}</strong></td>
      <td><span class="type-badge ${typeClass}">${r.type}</span></td>
      <td><span class="grade-badge" style="background:${GRADE_COLORS[r.grade]}22;color:${GRADE_COLORS[r.grade]}">${r.grade}</span></td>
      <td>${r.perDay.toFixed(1)}</td>
      <td>${(r._fc || r.count).toLocaleString()}</td>
      <td>${r.avgSev.toFixed(2)}</td>
      <td>${r.topCause}</td>
      <td>${r.medDur > 0 ? (r.medDur < 1 ? Math.round(r.medDur * 60) + 'm' : r.medDur.toFixed(1) + 'h') : 'â€”'}</td>
      <td><div class="sev-bar"><div class="s" style="width:${sp}%"></div><div class="w" style="width:${wp}%"></div><div class="i" style="width:${(100-sp-wp)}%"></div></div></td>
    </tr>`;
  }).join('');

  tbody.querySelectorAll('tr').forEach(tr => {
    tr.setAttribute('tabindex', '0');
    tr.setAttribute('role', 'button');
    tr.addEventListener('keydown', e => {
      if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); tr.click(); }
    });
    tr.addEventListener('click', () => {
      const rid = tr.dataset.route;
      _modalTrigger = tr;
      selectedRoute = rid;
      renderRouteTable();
      openRouteModal(rid);
      // Highlight on map
      if (mapLayers[rid]) {
        mapLayers[rid].setStyle({ weight: 8, opacity: 1 });
        mapLayers[rid].bringToFront();
        mapLayers[rid].openPopup();
      }
    });
  });
}

// â”€â”€â”€â”€ Focus Trap Utility â”€â”€â”€â”€
let _modalTrigger = null;
function trapFocus(overlayEl) {
  const focusable = overlayEl.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
  if (!focusable.length) return;
  const first = focusable[0], last = focusable[focusable.length - 1];
  overlayEl._trapHandler = e => {
    if (e.key !== 'Tab') return;
    if (e.shiftKey) {
      if (document.activeElement === first) { e.preventDefault(); last.focus(); }
    } else {
      if (document.activeElement === last) { e.preventDefault(); first.focus(); }
    }
  };
  overlayEl.addEventListener('keydown', overlayEl._trapHandler);
  first.focus();
}
function releaseFocus(overlayEl) {
  if (overlayEl._trapHandler) {
    overlayEl.removeEventListener('keydown', overlayEl._trapHandler);
    delete overlayEl._trapHandler;
  }
  if (_modalTrigger) { _modalTrigger.focus(); _modalTrigger = null; }
}

// â”€â”€â”€â”€ Route Modal (#13: fixed label) â”€â”€â”€â”€
document.getElementById('modalClose').addEventListener('click', closeModal);
document.getElementById('routeModal').addEventListener('click', e => {
  if (e.target === document.getElementById('routeModal')) closeModal();
});

function closeModal() {
  const overlay = document.getElementById('routeModal');
  overlay.classList.remove('show');
  releaseFocus(overlay);
  selectedRoute = null;
  renderRouteTable();
  if (charts.modalTrend) charts.modalTrend.destroy();
  if (charts.modalSev) charts.modalSev.destroy();
}

function openRouteModal(routeId) {
  const route = DATA.routeTable.find(r => r.id === routeId);
  if (!route) return;

  const { start, end } = getFilteredMonthIndices();
  const days = getTotalDays(start, end);
  // Compute filtered counts from monthly data
  let filteredCount = 0;
  DATA.months.forEach((m, i) => { if (i >= start && i <= end) filteredCount += (route.months[m] || 0); });
  let filteredSevere = 0;
  if (route.monthlySev) {
    const sevVals = route.monthlySev['SEVERE'] || [];
    for (let i = start; i <= end; i++) filteredSevere += (sevVals[i] || 0);
  } else {
    filteredSevere = route.severe;
  }
  const perDay = days > 0 ? (filteredCount / days).toFixed(1) : '0';
  const sevPerDay = days > 0 ? (filteredSevere / days).toFixed(1) : '0';
  const grade = getGrade(days > 0 ? filteredSevere / days : 0);

  document.getElementById('modalTitle').innerHTML =
    `${route.displayName || route.id} &mdash; ${route.type} <span class="grade-badge" style="background:${GRADE_COLORS[grade]}22;color:${GRADE_COLORS[grade]};margin-left:8px">${grade}</span>`;
  const dur = route.duration || {};
  const durStr = dur.count > 0 ? (dur.median < 1 ? Math.round(dur.median * 60) + ' min' : dur.median.toFixed(1) + ' hrs') : 'â€”';
  const dur90Str = dur.count > 0 ? (dur.p90 < 1 ? Math.round(dur.p90 * 60) + ' min' : dur.p90.toFixed(1) + ' hrs') : 'â€”';

  document.getElementById('modalStats').innerHTML = `
    <div class="stat"><div class="label">Alerts/Day</div><div class="val">${perDay}</div></div>
    <div class="stat"><div class="label">Severe/Day</div><div class="val" style="color:var(--red)">${sevPerDay}</div></div>
    <div class="stat"><div class="label">Median Duration</div><div class="val" style="color:var(--accent)">${durStr}</div></div>
    <div class="stat"><div class="label">90th %ile Duration</div><div class="val" style="color:var(--orange)">${dur90Str}</div></div>
    <div class="stat"><div class="label">Total</div><div class="val">${route.count.toLocaleString()}</div></div>
    <div class="stat"><div class="label">Top Cause</div><div class="val" style="font-size:16px">${route.topCause}</div></div>
    <div class="stat"><div class="label">Top Effect</div><div class="val" style="font-size:16px">${route.topEffect}</div></div>
  `;

  // Monthly trend
  const monthData = DATA.months.map(m => route.months[m] || 0);
  const mcc = getChartColors();
  if (charts.modalTrend) charts.modalTrend.destroy();
  charts.modalTrend = new Chart(document.getElementById('modalTrendChart'), {
    type: 'line',
    data: {
      labels: DATA.months.map(MONTH_SHORT),
      datasets: [{
        label: 'Alerts',
        data: monthData,
        borderColor: getComputedStyle(document.documentElement).getPropertyValue('--accent').trim(),
        backgroundColor: getComputedStyle(document.documentElement).getPropertyValue('--accent').trim() + '1a',
        fill: true, tension: 0.3, pointRadius: 5,
        pointBackgroundColor: getComputedStyle(document.documentElement).getPropertyValue('--accent').trim(),
      }],
    },
    options: {
      responsive: true, maintainAspectRatio: false,
      plugins: { legend: { display: false } },
      scales: {
        x: { ticks: { color: mcc.tick }, grid: { color: mcc.grid } },
        y: { ticks: { color: mcc.tick }, grid: { color: mcc.grid }, beginAtZero: true },
      },
    },
  });

  // Severity breakdown (was mislabeled "Cause Breakdown" â€” #13 fixed)
  if (charts.modalSev) charts.modalSev.destroy();
  const sevData = [
    { label: 'Severe', value: route.severe, color: SEV_COLORS.SEVERE },
    { label: 'Warning', value: route.warning, color: SEV_COLORS.WARNING },
    { label: 'Info', value: route.info, color: SEV_COLORS.INFO },
  ].filter(d => d.value > 0);

  charts.modalSev = new Chart(document.getElementById('modalSevChart'), {
    type: 'bar',
    data: {
      labels: sevData.map(d => d.label),
      datasets: [{ data: sevData.map(d => d.value), backgroundColor: sevData.map(d => d.color), borderRadius: 6 }],
    },
    options: {
      indexAxis: 'y', responsive: true, maintainAspectRatio: false,
      plugins: { legend: { display: false } },
      scales: {
        x: { ticks: { color: mcc.tick }, grid: { color: mcc.grid } },
        y: { ticks: { color: mcc.label }, grid: { display: false } },
      },
    },
  });

  const overlay = document.getElementById('routeModal');
  overlay.classList.add('show');
  trapFocus(overlay);
}

// â”€â”€â”€â”€ Tooltip â”€â”€â”€â”€
function showTooltip(event, title, value, detail) {
  const tt = document.getElementById('tooltip');
  tt.querySelector('.tt-title').textContent = title;
  tt.querySelector('.tt-value').textContent = value;
  tt.querySelector('.tt-detail').textContent = detail;
  tt.style.display = 'block';
  const rect = event.target.getBoundingClientRect();
  tt.style.left = (rect.left + rect.width / 2) + 'px';
  tt.style.top = (rect.top - 70) + 'px';
}
function hideTooltip() { document.getElementById('tooltip').style.display = 'none'; }

document.addEventListener('keydown', e => {
  if (e.key === 'Escape') {
    closeModal();
    const aboutOv = document.getElementById('aboutOverlay');
    if (aboutOv.classList.contains('show')) {
      aboutOv.classList.remove('show');
      releaseFocus(aboutOv);
    }
    document.getElementById('helpPopup').style.display = 'none';
  }
});
</script>
</body>
</html>
